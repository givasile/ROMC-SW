\documentclass[article]{jss}
%% -- LaTeX packages and custom commands ---------------------------------------

\usepackage[usenames,dvipsnames]{xcolor}

%% recommended packages
\usepackage{thumbpdf,lmodern}

%% Vasilis packages
\usepackage{amsmath,amssymb,bbold, xfrac}

\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption} % for subfigure
\usepackage{float}

%% TikZ packages
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, backgrounds, scopes}
\usepackage{pgfplots}
\pgfplotsset{width=6.75cm, compat=newest}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{2212}{âˆ’}
\usepgfplotslibrary{groupplots,dateplot}
\usetikzlibrary{patterns,shapes.arrows}

%% for algorithms
\usepackage{algorithm}
\usepackage{algpseudocode} % algorithmicx package

%% another package (only for this demo article)
\usepackage{framed}
\usepackage{marginnote}

%% new custom commands
\newcommand{\class}[1]{`\code{#1}'}
\newcommand{\fct}[1]{\code{#1()}}

%% Vasilis' custom commands
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\X}{\mathbf{x}}
\newcommand{\Z}{\mathbf{z}}
\newcommand{\V}{\mathbf{V}}
\newcommand{\Y}{\mathbf{Y}}
\newcommand{\hess}{\mathbf{H}}
\newcommand{\Thetab}{\mathbf{\Theta}}

\newcommand{\vb}{\mathbf{v}}
\newcommand{\yb}{\mathbf{y}}
\newcommand{\xb}{\mathbf{x}}

\newcommand{\jac}{\mathbf{J}}
\newcommand{\hessian}{\mathbf{H}}
\newcommand{\thetab}{\boldsymbol{\theta}}
\newcommand{\thetabij}{\thetab_{ij}}
\newcommand{\thetabi}{\thetab_i}

\newcommand{\simulator}{g}
\newcommand{\region}{B_{d,\epsilon}}
\newcommand{\indicator}[1]{\mathbb{1}_{#1}}
\newcommand{\regioni}{B_{d,\epsilon}^i}
\newcommand{\data}{\mathbf{y_0}}
\newcommand{\accregioni}{C^i_{\epsilon}}
\newcommand{\accregionihat}{\hat{C}^i_{\epsilon}}

\newcommand{\danger}{\fontencoding{U}\fontfamily{futs}\selectfont\char 66\relax}
\newcommand{\TODO}[1]{\textcolor{red}{TODO #1}\marginpar{\textcolor{red}{\Large \danger}}}


\newcommand{\R}{\mathbb{R}}

\newcommand{\Ex}{\mathbb{E}}

\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}

%% -- Article metainformation (author, title, ...) -----------------------------

%% - \author{} with primary affiliation
%% - \Plainauthor{} without affiliations
%% - Separate authors by \And or \AND (in \author) or by comma (in \Plainauthor).
%% - \AND starts a new line, \And does not.
\author{Vasilis Gkolemis\\ATHENA RC
  \And Michael Gutmann\\University of Edinburgh
   \And Henri Pesonen \\University of Oslo
}
\Plainauthor{Vasilis Gkolemis, Michael Gutmann}


%% - \title{} in title case
%% - \Plaintitle{} without LaTeX markup (if any)
%% - \Shorttitle{} with LaTeX markup (if any), used as running title
\title{An Extendable \proglang{Python} Implementation of Robust Optimisation Monte Carlo}
\Plaintitle{An Extendable Python Implementation of ROMC}
\Shorttitle{An Extendable \proglang{Python} Implementation of ROMC}

%% - \Abstract{} almost as usual
\Abstract{ Performing the inference in statistical models with
  intractable likelihood is challenging; most likelihood-free
  inference (LFI) methods encounter problems in accuracy and
  efficiency. In this paper, we present the implementation of Robust
  Optimisation Monte Carlo (ROMC) in the Python package ELFI. ROMC is
  a novel and efficient (highly-parallelizable) LFI technique that
  provides accurate weighted samples from the posterior.  Our
  implementation can be used in two ways. A scientist may use it as an
  out-of-the-box LFI algorithm. We provide an easy-to-use API
  harmonised with the rest of the ELFI framework; therefore, it is
  straightforward to compare it with all the methods included in
  ELFI. On the other direction, we have carefully split ROMC into
  isolated algorithmic steps. Therefore, we allow the researcher to
  experiment, replacing components of the algorithm with
  custom-designed subparts. In both scenarios, the algorithmic steps
  of ROMC run in a fully-parallelizable manner, exploiting all CPU
  cores. We also provide helpful functionalities for (i) inspecting
  the inference process and (ii) evaluating the approximated
  posterior. Finally, we test the robustness of our implementation on
  some typical LFI examples.
  
  % This short article illustrates how to write a manuscript for the
  % \emph{Journal of Statistical Software} (JSS) using its {\LaTeX} style files.
  % Generally, we ask to follow JSS's style guide and FAQs precisely. Also,
  % it is recommended to keep the {\LaTeX} code as simple as possible,
  % i.e., avoid inclusion of packages/commands that are not necessary.
  % For outlining the typical structure of a JSS article some brief text snippets
  % are employed that have been inspired by \cite{Zeileis+Kleiber+Jackman:2008},
  % discussing count data regression in \proglang{R}. Editorial comments and
  % instructions are marked by vertical bars.
}

%% - \Keywords{} with LaTeX markup, at least one required
%% - \Plainkeywords{} without LaTeX markup (if necessary)
%% - Should be comma-separated and in sentence case.
\Keywords{Bayesian Inference, Simulator-based models, Likelihood-free, \proglang{Python}, \proglang{ELFI}}
\Plainkeywords{Bayesian Inference, Simulator-based models, Likelihood-free, Python, ELFI}

%% - \Address{} of at least one author
%% - May contain multiple affiliations for each author
%%   (in extra lines, separated by \emph{and}\\).
%% - May contain multiple authors for the same affiliation
%%   (in the same first line, separated by comma).
\Address{
  Vasilis Gkolemis\\
  Information Management Systems Institute (IMSI)\\
  ATHENA Research and Innovation Center\\
  Athens, Greece\\
  E-mail: \email{vgkolemis@athenarc.gr}\\
  URL: \url{https://givasile.github.io}
}

\begin{document}

%% See jss_template_article.tex for formatting instructions and macros to e.g. typset code
%% I only kept the informative sidebars as comments

%% -- Introduction -------------------------------------------------------------

%% - In principle "as usual".
%% - But should typically have some discussion of both _software_ and _methods_.
%% - Use \proglang{}, \pkg{}, and \code{} markup throughout the manuscript.
%% - If such markup is in (sub)section titles, a plain text version has to be
%%   added as well.
%% - All software mentioned should be properly \cite-d.
%% - All abbreviations should be introduced.
%% - Unless the expansions of abbreviations are proper names (like "Journal
%%   of Statistical Software" above) they should be in sentence case (like
%%   "generalized linear models" below).

% \section[Introduction: Count data regression in R]{Introduction: Count data regression in \proglang{R}} \label{sec:intro}
\section{Introduction} \label{sec:intro}

Simulator-based models are particularly captivating due to the
modelling freedom they provide. In essence, a simulator-based model can
describe any data generating mechanism that can be written as a finite
set of algorithmic steps. This modelling freedom comes at a cost;
performing the inference, i.e., sample or evaluate the posterior
distribution, is challenging.

Optimization Monte Carlo (OMC) proposed by~\citep{Meeds2015} was a
novel LFI approach for approximating the posterior
distribution. Afterwards, \citep{Forneron2016} provided a similar
method under `reverse sampler'. The key idea is turning the stochastic
data-generating mechanism into a set of fully-parallelizable
deterministic optimisation processes. In their work,
~\citet{Ikonomov2019}, located some critical failure modes of OMC, and
proposed Robust OMC (ROMC) an alternative version of OMC with the
appropriate improvements.

In this paper, we present an extendible and parallelisable
implementation of ROMC at the \proglang{Python} package
\proglang{Engine for Likelihood-Free inference (ELFI)}. We follow
specific principles for making the implementation extendible. As we
will describe analytically in the next chapter, ROMC can be understood
not only as a specific algorithm, but mainly as a framework for
obtaining weighted samples from the posterior; it defines some
algorithmic task that must be fulfilled, without enforcing which
specific algorithm must be used for the tasks. Therefore, a researcher
may adopt ROMC's backbone approach, but experiment with alternative
methods to solve the distinct tasks. We have designed ROMC for
facilitating such alterations. Finally, we have tested the accuracy and
the efficiency of our implementation on the LFI examples supported by
the \proglang{ELFI} package.

% \begin{leftbar}
% The introduction is in principle ``as usual''. However, it should usually embed
% both the implemented \emph{methods} and the \emph{software} into the respective
% relevant literature. For the latter both competing and complementary software
% should be discussed (within the same software environment and beyond), bringing
% out relative (dis)advantages. All software mentioned should be properly
% \verb|\cite{}|d. (See also Appendix~\ref{app:bibtex} for more details on
% \textsc{Bib}{\TeX}.)

% For writing about software JSS requires authors to use the markup
% \verb|\proglang{}| (programming languages and large programmable systems),
% \verb|\pkg{}| (software packages), \verb|\code{}| (functions, commands,
% arguments, etc.). If there is such markup in (sub)section titles (as above), a
% plain text version has to be provided in the {\LaTeX} command as well. Below we
% also illustrate how abbrevations should be introduced and citation commands can
% be employed. See the {\LaTeX} code for more details.
% \end{leftbar}


%% -- Manuscript ---------------------------------------------------------------

%% - In principle "as usual" again.
%% - When using equations (e.g., {equation}, {eqnarray}, {align}, etc.
%%   avoid empty lines before and after the equation (which would signal a new
%%   paragraph.
%% - When describing longer chunks of code that are _not_ meant for execution
%%   (e.g., a function synopsis or list of arguments), the environment {Code}
%%   is recommended. Alternatively, a plain {verbatim} can also be used.
%%   (For executed code see the next section.)


% \begin{leftbar}
% As the synopsis above is a code listing that is not meant to be executed,
% one can use either the dedicated \verb|{Code}| environment or a simple
% \verb|{verbatim}| environment for this. Again, spaces before and after should be
% avoided.

% Finally, there might be a reference to a \verb|{table}| such as
% Table~\ref{tab:overview}. Usually, these are placed at the top of the page
% (\verb|[t!]|), centered (\verb|\centering|), with a caption below the table,
% column headers and captions in sentence style, and if possible avoiding vertical
% lines.
% \end{leftbar}

%% -- Illustrations ------------------------------------------------------------

% - Virtually all JSS manuscripts list source code along with the generated
%   output. The style files provide dedicated environments for this.
% - In R, the environments {Sinput} and {Soutput} - as produced by Sweave() or
%   or knitr using the render_sweave() hook - are used (without the need to
%   load Sweave.sty).
% - Equivalently, {CodeInput} and {CodeOutput} can be used.
% - The code input should use "the usual" command prompt in the respective
%   software system.
% - For R code, the prompt "R> " should be used with "+  " as the
%   continuation prompt.
% - Comments within the code chunks should be avoided - these should be made
%   within the regular LaTeX text.


% \begin{leftbar}
% For code input and output, the style files provide dedicated environments.
% Either the ``agnostic'' \verb|{CodeInput}| and \verb|{CodeOutput}| can be used
% or, equivalently, the environments \verb|{Sinput}| and \verb|{Soutput}| as
% produced by \fct{Sweave} or \pkg{knitr} when using the \code{render_sweave()}
% hook. Please make sure that all code is properly spaced, e.g., using
% \code{y = a + b * x} and \emph{not} \code{y=a+b*x}. Moreover, code input should
% use ``the usual'' command prompt in the respective software system. For
% \proglang{R} code, the prompt \code{"R> "} should be used with \code{"+  "} as
% the continuation prompt. Generally, comments within the code chunks should be
% avoided -- and made in the regular {\LaTeX} text instead. Finally, empty lines
% before and after code input/output should be avoided (see above).
% \end{leftbar}

% \clearpage
\section{Background}
We first give a short introduction to implicit parametric models and
LFI. We then focus on the methods relevant for
this paper: first the earlier OMC and then
its recent robust generalisation, robust OMC, for which we provide the
software package as part of ELFI, a larger inference platform that we briefly introduce at the
end of this background section.

%\input{latex_files/ch2/2_1_implicit_models}

\subsection{Implicit models and likelihood-free inference}
\input{latex_files/ch2/2-1-implicit-models.tex}

\subsection{Optimisation Monte Carlo (OMC)}
\input{latex_files/ch2/2-2-OMC.tex}


\subsection{Robust optimisation Monte Carlo (ROMC)}
\input{latex_files/ch2/2-3-ROMC.tex}

\subsection{Engine for likelihood-free inference (ELFI)}
\label{subsec:ELFI}
\input{latex_files/ch2/2-4-ELFI.tex}

%% -- Design Principles -----------------------------------------------------
\section{Design principles}  % better title needed

\input{latex_files/ch3/3-0-design-principles.tex}

\subsection{General implementation principles}
\label{subsec:general_design}
\input{latex_files/ch3/3-1-implementation-principles.tex}

%% -- ROMC implementation ----------------------------------------------------
\section{Implemented functionalities}

In this section, we present the implementation. At~\ref{subsec:ELFI}
we introduce the reader to the \proglang{Python} package \pkg{ELFI}. At~\ref{subsec:general_design} we explain the general
design that we follow. Then, we divide the implementation into three
parts; at~\ref{subsec:training} we present the training (fitting)
part, at~\ref{subsec:inference} the inference part and
at~\ref{subsec:evaluation} the evaluation part. Finally,
at~\ref{subsec:extensibility} we describe how a user may extend ROMC
with its custom modules.

\subsection{Training part} 
\label{subsec:training}
\input{latex_files/ch4/4-1-training.tex}

\subsection{Inference part} 
\label{subsec:inference}
\input{latex_files/ch4/4-2-inference.tex}

\subsection{Evaluation part} 
\label{subsec:evaluation}
\input{latex_files/ch4/4-3-evaluation.tex}

\subsection{Extensibility} % better title
\label{subsec:extensibility}
\input{latex_files/ch4/4-4-extensibility.tex}

%% -- Use-case illustration ----------------------------------------------------
\section{Use-case illustration}

In this section, we test the implementation using the second-order
moving average (MA2) example, which is one of the standard models of
\pkg{ELFI}. We perform the inference using three different versions of
ROMC; (i) using a gradient-based optimiser, (ii) using the Bayesian
Optimisation scheme and (iii) fitting a Neural Network as a surrogate
model. The later illustrates how to extend the implementation,
replacing part of ROMC with a user-defined component. Finally, we
measure the execution speed-up achieved by the parallelised version of
ROMC.

% \subsection{Moving average example}
% \label{subsec:ma2}
\input{latex_files/ch5/5-1-ma2.tex}

% \subsection{Execution time}
% \label{subsec:exec_time}
% \input{latex_files/ch5/5-2-execution-time.tex}


%% -- Summary/conclusions/discussion -------------------------------------------
\section{Summary and discussion} \label{sec:summary}

In this paper, we presented the implementation details we followed for
developing the LFI method ROMC at the \pkg{ELFI} package. We paid
thorough attention to two specific use-case scenarios. Firstly, we
illustrate how a user may take advantage of our ready-to-use API for
solving its LFI problem. Secondly, we focus on the scenario where a
researcher wants to intervene and alter parts of the method. Our
implementation is designed to support this as well.

There are still open challenges for the left for future research. Two
directions may enable ROMC to solve high-dimensional problems
efficiently. The first one is enabling ROMC's execution into a cluster
of computers. ROMC can be characterized as an \textit{embarrassingly
  parallel} workload; each optimization problem is an entirely
independent task. Therefore, supporting inference into a cluster of
computers can radically speed up the inference. The second one refers
to implementing the method in a framework that supports automatic
differentiation. Automatic differentiation is necessary for
efficiently solving optimisation problems, especially in
high-dimensional parametric models.

%% -- Optional special unnumbered sections -------------------------------------

% \section*{Computational details}

% \begin{leftbar}
% If necessary or useful, information about certain computational details
% such as version numbers, operating systems, or compilers could be included
% in an unnumbered section. Also, auxiliary packages (say, for visualizations,
% maps, tables, \dots) that are not cited in the main text can be credited here.
% \end{leftbar}

% The results in this paper were obtained using
% \proglang{R}~3.4.1 with the
% \pkg{MASS}~7.3.47 package. \proglang{R} itself
% and all packages used are available from the Comprehensive
% \proglang{R} Archive Network (CRAN) at
% \url{https://CRAN.R-project.org/}.

% \section*{Acknowledgments}

% \begin{leftbar}
% All acknowledgments (note the AE spelling) should be collected in this
% unnumbered section before the references. It may contain the usual information
% about funding and feedback from colleagues/reviewers/etc. Furthermore,
% information such as relative contributions of the authors may be added here
% (if any).
% \end{leftbar}


%% -- Bibliography -------------------------------------------------------------
%% - References need to be provided in a .bib BibTeX database.
%% - All references should be made with \cite, \citet, \citep, \citealp etc.
%%   (and never hard-coded). See the FAQ for details.
%% - JSS-specific markup (\proglang, \pkg, \code) should be used in the .bib.
%% - Titles in the .bib should be in title case.
%% - DOIs should be included where available.

\bibliography{refs}


%% -- Appendix (if any) --------------------------------------------------------
%% - After the bibliography with page break.
%% - With proper section titles and _not_ just "Appendix".

% \newpage

% \begin{appendix}

% \section{More technical details} \label{app:technical}

% \begin{leftbar}
% Appendices can be included after the bibliography (with a page break). Each
% section within the appendix should have a proper section title (rather than
% just \emph{Appendix}).

% For more technical style details, please check out JSS's style FAQ at
% \url{https://www.jstatsoft.org/pages/view/style#frequently-asked-questions}
% which includes the following topics:
% \begin{itemize}
%   \item Title vs.\ sentence case.
%   \item Graphics formatting.
%   \item Naming conventions.
%   \item Turning JSS manuscripts into \proglang{R} package vignettes.
%   \item Trouble shooting.
%   \item Many other potentially helpful details\dots
% \end{itemize}
% \end{leftbar}


% \section[Using BibTeX]{Using \textsc{Bib}{\TeX}} \label{app:bibtex}

% \begin{leftbar}
% References need to be provided in a \textsc{Bib}{\TeX} file (\code{.bib}). All
% references should be made with \verb|\cite|, \verb|\citet|, \verb|\citep|,
% \verb|\citealp| etc.\ (and never hard-coded). This commands yield different
% formats of author-year citations and allow to include additional details (e.g.,
% pages, chapters, \dots) in brackets. In case you are not familiar with these
% commands see the JSS style FAQ for details.

% Cleaning up \textsc{Bib}{\TeX} files is a somewhat tedious task -- especially
% when acquiring the entries automatically from mixed online sources. However,
% it is important that informations are complete and presented in a consistent
% style to avoid confusions. JSS requires the following format.
% \begin{itemize}
%   \item JSS-specific markup (\verb|\proglang|, \verb|\pkg|, \verb|\code|) should
%     be used in the references.
%   \item Titles should be in title case.
%   \item Journal titles should not be abbreviated and in title case.
%   \item DOIs should be included where available.
%   \item Software should be properly cited as well. For \proglang{R} packages
%     \code{citation("pkgname")} typically provides a good starting point.
% \end{itemize}
% \end{leftbar}

% \end{appendix}

%% -----------------------------------------------------------------------------

\end{document}
