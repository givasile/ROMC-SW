The ROMC implementation provides two functions for evaluating the
inference results.

\begin{Code}
---------------------------------- python ----------------------------------  
>>> romc.compute_divergence(gt_posterior,
                            bounds=None,
                            step=0.1,
                            distance="Jensen-Shannon")
>>> romc.compute_ess()
----------------------------------------------------------------------------
\end{Code}

\noindent
This function computes the divergence between the ROMC approximation
and the ground truth posterior. Since the computation is performed
using the Riemann's approximation, this method can only work in low
dimensional parameter spaces; it is suggested to be used for up to the
three-dimensional parameter space. As mentioned at the beginning of
this chapter, in a real-case scenario it is not expected the
ground-truth posterior to be available. However, in cases where the
posterior can be approximated decently well with a numerical approach
(as in the current example) or with some other inference approach,
this function can provide a numerical measure of the agreement between
the two approximations. The argument \code{step} defines the step used
in the Riemann's approximation and the argument \code{distance} can
take either the \code{Jensen-Shannon} or the \code{KL-divergence}
value, for computing the appropriate distance. \code{compute_ess}
computes the Effective Sample Size (ESS) using the following
expression~\cite{Sudman1967},

\begin{equation} \label{eq:ESS}
  ESS = \frac{(\sum_i w_i)^2}{\sum_i w_i^2}
\end{equation}

The ESS is a valuable measure of the \textbf{actual} sample size when
the samples are weighted. For example, if in a population of $100$
samples one has an enormous weight (e.g.\ $\approx 100$) whereas the
rest have small (i.e.\ $\approx 1$), the actual sample size is close
to 1; one sample dominates over the rest. Hence, the ESS provides a
measure of the equivalent uniformly weighted sample population.

\begin{Code}
------------------------------ python snippet ------------------------------  
  # Evaluation part
  res = romc.compute_divergence(wrapper, distance="Jensen-Shannon")                                 
  print("Jensen-Shannon divergence: %.3f" % res)
  # Jensen-Shannon divergence: 0.025

  nof_samples = len(romc.result.weights)
  ess = romc.compute_ess()
  print("Nof Samples: %d, ESS: %.3f" % (nof_samples, ess))
  # Nof Samples: 19300, ESS: 16138.825
----------------------------------------------------------------------------  
\end{Code}
