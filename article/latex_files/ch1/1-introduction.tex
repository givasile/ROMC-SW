Simulator-based models are particularly captivating due to the
provided modeling freedom. In essence, any data generating mechanism
that can be written as a finite set of algorithmic steps can be
programmed as a simulator-based model. In these cases, it is feasible
to generate samples using the simulator but it is infeasible to
evaluate the likelihood function. The intractability of the likelihood
makes the likelihood-free inference (LFI), i.e., the approximation of
the posterior distribution without using the likelihood function,
particularly challenging.

Optimization Monte Carlo (OMC) proposed by~\citet{Meeds2015} is a
novel LFI approach for approximating the posterior distribution. The
central idea is turning the stochastic data-generating mechanism into
a set of deterministic optimization processes. Afterwards,
\citet{Forneron2016} provided a similar method under the name `reverse
sampler'. In their work,~\citet{Ikonomov2019}, located some critical
limitations of OMC, so they proposed Robust OMC (ROMC), an alternative
version of OMC with the appropriate modifications.

In this paper, we present the implementation of ROMC at the
\proglang{Python} package \pkg{ELFI} (Engine for likelihood-free
inference)~\citet{1708.00707}. As we illustrate at
Section~\ref{sec:implementation}, we have carefully designed the
implementation to ensure extensibility. ROMC is a general framework
for obtaining weighted samples from the posterior, i.e., it defines a
sequence of algorithmic steps without enforcing a specific algorithm
for solving each step. Therefore, a researcher may use ROMC as the
backbone algorithm and develop novel methods to solve each separate
step.\footnote{For being a ready-to-use
algorithm,~\citet{Ikonomov2019} proposed a default method for each
step, but this choice is by no means restrictive.} We have designed
our software for facilitating such experimentation.

To the best of our knowledge, this is the first implementation of the
ROMC inference method to a generic LFI framework. We organize the
evaluation in three steps. First, for securing that our implementation
is accurate, we test it against an artificial example with a tractable
likelihood. The artificial example also serves as a step-by-step guide
for showcasing how to use the various functionalities of our
implementation. Second, we use the second-order moving average (MA2)
example from the \pkg{ELFI} package, using as ground truth the samples
obtained with Rejection ABC~\citet{lintusaari2017}, with a very large
number of trials. Finally, we present the execution times of ROMC,
measuring the speed-up obtained by using the parallel version of the
implementation.
